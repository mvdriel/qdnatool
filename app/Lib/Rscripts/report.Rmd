---
html_document: null
fig_width: 11
classoption: landscape
keep_md: yes
output: html_document
pdf_document: default
---

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(ggplot2)
library(pander)
library(plyr)
```


```{r, echo = FALSE, eval = TRUE, results = "asis"}

CreateItemList <- function(number.answeroptions, correct.frequency,
  correct.percentage, frequency.answer.options, percentage.answer.options,
  corrected.item.tot.cor, corrected.item.tot.cor.answ.option, item.names, key) {
  # Creates a list with frequency, percentage correct, and IRC for every item.
  #
  # Args:
  #  number.answeroptions: Vector with number of answer options per item
  #  frequency.answer.options: Matrix with [i,j] the frequency of
  #    answer option i of item j
  #  percentage.answer.options: Matrix with [i,j] the percentage of
  #    answer option i of item j
  #  corrected.item.tot.cor.answ.option: Matrix with [i,j] the item total
  #    correlation for answer option i of item j
  #  correct.frequency: Vector with total number correct per item
  #  correct.percentage: Vector with percentage correct per item
  #  corrected.item.tot.cor: Vector with item rest correlation per item
  #
  # Returns:
  #  List with one entry per item. Each entry consists of a data frame with
  #  frequency, percentage and IRC for the total item and the answer options
  #  (if the item has answer options)

  item.list <- list() #  Creates list to put item output in
  colnames1 <- c(" ", "Frequency", "Percentage", "IRC")
  colnames2 <- c("Answer Option", "Frequency", "Percentage", "IRC", "Correct")

  # For every item, create entry in list with frequencies, percentages, and IRCs
  for (i in 1:length(item.names)) {
    if (number.answeroptions[i] > 0) {
      correct <- c(ifelse(key[1:number.answeroptions[i], i] == 1,
                          "Correct", "Incorrect"), "Incorrect")

      item.list[[i]] <- data.frame(
        c(LETTERS[1:number.answeroptions[i]], "Missing"),
        c(frequency.answer.options[c(2: (number.answeroptions[i] + 1), 1), i]),
        c(percentage.answer.options[c(2: (number.answeroptions[i] + 1), 1), i]),
        c(corrected.item.tot.cor.answ.option[c(2: (number.answeroptions[i] + 1),
                                               1), i]),
        correct,
        row.names = NULL)
      colnames(item.list[[i]]) <- colnames2

    } else {
      item.list[[i]] <- data.frame("Correct", correct.frequency[i],
                                    correct.percentage[i],
                                    corrected.item.tot.cor[i])
      colnames(item.list[[i]]) <- colnames1
     }
  }

  names(item.list) <- item.names #  Attach item names
  return(item.list)
}

# Use the function defined above
item.list <- CreateItemList(number.answeroptions, correct.frequency,
  correct.percentage, frequency.answer.options, percentage.answer.options,
  corrected.item.tot.cor, corrected.item.tot.cor.answ.option, item.names, key)

cat(paste("#", title))
```

# General

What | Result |
:---------------------- | :------------- |
Number of students | `r length(student.scores)`|
Number of items | `r length(item.names)`|
Average score | `r round(mean(student.scores), digits = 3)`|
Standard deviation | `r round(sd(student.scores), digits = 3)`| 
Cronbach's alpha | `r cronbach`| 
Standard error | `r round(sd(student.scores * sqrt(1 - cronbach)), digits = 3)`| 


# Item statistics

For each item the frequency, percentage and item rest correlations (IRC) of 
every answer option are shown The IRC should be (highly) positive for the 
right answer option and low for the wrong answer option(s).

```{r pander, results = "asis", eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE}

pander.table <- function(item.list, key) {
  # Print table for each item with frequency, percentage and the
  # item-rest correlation. Correct answers are highlighted in bold
  #
  # Args:
  #  item.list: list with one entry per item. Each entry consists of a data frame
  #             Data frame has a row for every answer option + one for missing.
  #             Columns are: Answer option, frequency, percentage, IRC,
  #                          and Correct (answer option is Correct/Incorrect)
  #            Length should be the same as number of columns of key
  #  key: Matrix of 0's and 1's. key[i,j] implies wether answer option i
  #       to item j is right (1) or wrong (0). If a column (item) consists of
  #       only 0s, the item is interpreted as graded manually.
  #       Number of columns should be equal to length of item.list

  panderOptions("knitr.auto.asis", FALSE)
  for (i in 1:length(item.list)) {
    if (any(key[, i] == 1)) {
      item.list[[i]]$Correct <- revalue(item.list[[i]]$Correct,
                                        c("Correct" = "X", "Incorrect" = ""))
      emphasize.strong.rows(which(key[, i] == 1, arr.ind = TRUE))
      pander(item.list[i])
    } else {
      t <- item.list[i]
      pander(t)
    }
  }
}

pander.table(item.list, key)
```

\pagebreak

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.width = 11, results = 'asis'}

CreateDf <- function(item.names, correct.percentage, corrected.item.tot.cor) {
  # Creates a data frame with the overall item statistics including a colour
  # indicator for the percentage correct and IRC. Colours is defined below.
  #
  # Args:
  #  These are the same as defined in CreateItemList
  #
  # Returns:
  #  Data frame with a row for every item. Columns consist of the item name,
  #  percentage correct, colour indicator for percentage, IRC and colour
  #  indicator for the IRC.

  correct.df <- data.frame(item = factor(item.names, item.names),
    correct.percentage,
    perc.col = ifelse(correct.percentage < 40, 0,
                      ifelse(correct.percentage > 70, 1,
                             1 / 75 * correct.percentage - 7 / 30)),

    corrected.item.tot.cor,
    irc.col = ifelse(corrected.item.tot.cor < 0, 0,
                     ifelse(corrected.item.tot.cor > .05, 1,
                            8 * corrected.item.tot.cor + 3 / 10))
  )

  return(correct.df)
}

PercPlotOverall <- function(correct.df) {
  # Plots bar graph of percentage correct of every item. Bars are coloured
  # depending on the percentage correct:
  # < 40: Red
  # 40 - 70: Orange till green-ish
  # > 70: Green
  #
  # Args:
  #  correct.df: data frame with item name, percentage correct and colour code
  #  for the percentages.
  #
  # Returns:
  #  Explanation of the plot and the plot itself

  cat("

## Percentage Correct

Plot of percentage correct per item. If *more than 70%* of the students answer
an item correctly, the students have mastered the material well enough, thus it
is coloured *green*. If *less than 40%* of the students answer an item
correctly, the students have not mastered the material, and is coloured *red*.
*Orange* indicates the percentage correct lies *between 40% and 70%*. The
colours are based on multiple choice items with 3 or 4 answer options.

")

  bar.freq <- ggplot(correct.df, aes(item, correct.percentage, fill = perc.col))
  bar.freq <- bar.freq + geom_bar(stat = "identity") + #  Create Bar chart
    scale_fill_gradient(low = "red", high = "green", limits = c(0, 1),
                        guide = FALSE)  + #  Create colour boundray
    coord_cartesian(ylim = c(0, 100)) + #  Change y-axis limit to constant
    labs(x = "Item", y = "Percentage Correct") + #  x-axis name
    theme_bw() + #  Black and white
    theme(axis.text.x = element_text(size = 8, angle = 90), #  Change font size
          axis.ticks.x = element_line(size = .4))

  suppressWarnings(print(bar.freq))
}

IRCPlotOverall <- function(correct.df) {
  # Plots bar graph of IRC of every item. Bars are coloured by IRC:
  # < 0: Red
  # 0 - .10: Orange till green-ish
  # > .10: green
  #
  # Args:
  #  correct.df: data frame with item name, percentage correct and colour code
  #  for the percentages.
  #
  # Returns:
  #  Explanation of the plot and the plot itself

  cat("\\pagebreak

## Item rest correlations

Plot of Item Rest Correlations per item: The correlation between an item (0 for
wrong answers and 1 for right answers) and the sum of all other items. Items
with a correlation *higher than .05* indicate that students who answered this
item correctly answered the other items more often correctly than students who
answered this item incorrectly. Thus it is coloured *green*. Items with a
correlation *lower than 0* indicate no relationship between this item and the
other items, or that students who answered this item correctly answered the
other items more often incorrectly than students who answered this incorrectly,
thus it is coloured *red*. *Between 0 and .05*, an item is coloured *orange*.

")

  # Create bar chart
  bar.IRC <- ggplot(correct.df, aes(item, corrected.item.tot.cor,
                                    fill = irc.col))
  bar.IRC <-  bar.IRC + geom_bar(stat = "identity") + #  Create Bar chart
    scale_fill_gradient(low = "red", high = "green", limits = c(0, 1),
                        guide = FALSE) +
    theme_bw() +
    labs(x = "Item", y = "Item Rest Correlation") + #  axes names
    theme(strip.text.x = element_text(size = 7),
          axis.text.x = element_text(size = 8, angle = 90),
          axis.ticks.x = element_line(size = .4))

  suppressWarnings(print(bar.IRC))
}

correct.df <- CreateDf(item.names, correct.percentage, corrected.item.tot.cor)
PercPlotOverall(correct.df)
IRCPlotOverall(correct.df)
```

```{r, echo = FALSE, eval = TRUE, warning= FALSE, fig.width = 11}

# Create extra variables for the colours in the bar plots
PercCol <- function(percentage, correct) {
  # Calculate colours for the percentage answer options.
  # Args:
  #  percentage: Percentage answered per answer options
  #  correct: Vector of "Correct" and "Incorrect" of same length of percentage
  #
  # Returns:
  #  Value between 0 and 1. 0 corresponds to red and 1 to green in the plots.
  #  For the correct options:
  #    < 40: red
  #    40 - 70: organge - green-ish
  #    > 70: green
  #  For the incorrect options: difference between correct answer option and
  #  incorrect answer options are calculated. Colours are based on difference:
  #    < -10: Green
  #    -10 - 0: orange - green-ish
  #    > 0: green

  perc.col <- vector("numeric", length = length(correct))
  perc.col[correct == "Correct"] <- ifelse(percentage[correct == "Correct"]
    < 40, 0, ifelse(percentage[correct == "Correct"] > 70, 1,
                    1 / 75 * percentage[correct == "Correct"] - 7 / 30))
  dif <- percentage[correct == "Incorrect"] -
                    min(percentage[correct == "Correct"])
  perc.col[correct == "Incorrect"] <- ifelse(dif >= 0, 0,
                                      ifelse(dif < -10, 1,
                                             -1 / 25 * dif + 3 / 10))
  perc.col
}

IrcCol <- function(IRC, correct){
  # Calculate colours for the percentage answer options.
  #
  # Args:
  #  IRC: IRC per answer options. Same length as correct
  #  correct: Vector of "Correct" and "Incorrect" of same length of IRC
  #
  # Returns:
  #  Value between 0 and 1. 0 corresponds to red and 1 to green in the plots.
  #  For the correct answer options:
  #    < 0: red
  #    0 - 0.05: orange - green-ish
  #    > 0.05: green
  # For the incorrect answer options: difference between correct answer option
  # and incorrect answer option are calculated. Colours are based on this
  # difference:
  #    > 0: red
  #    -0.05 - 0: orange - green-ish
  #    < -0.05: red

  IRC.col <- numeric()
  IRC.col[correct == "Correct"] <- ifelse(IRC[correct == "Correct"] < 0, 0,
    ifelse(IRC[correct == "Correct"] > .05, 1,
      8 * IRC[correct == "Correct"] + 3 / 10))
  dif <- IRC[correct == "Incorrect"] - min(IRC[correct == "Correct"])
  IRC.col[correct == "Incorrect"] <- ifelse(dif >= 0, 0,
    ifelse(dif < -.05, 1, -8 * dif + 3 / 10))
  return(IRC.col)
}

CreateAnsDf <- function(item.list, key, number.answeroptions, item.names) {
  # Creates a data frame with the statistics per answer option including a
  # colour indicator for the percentage correct and IRC.
  #
  # Args:
  #  These are the same as defined earlier
  #
  # Returns:
  #  Data frame with a row for every answer option. Columns consist of the
  #  item name, answer options, frequency, percentage, IRC, Correct (whether
  #  an option is correct/incorrect), colour for percentage and colour for IRC

  for (i in 1:length(item.list)) {
    if (any(key[, i] != 0)) {
      item.list[[i]]$perc.col <- with(item.list[[i]],
                                      PercCol(Percentage, Correct))
      item.list[[i]]$IRC.col <- with(item.list[[i]],
                                     IrcCol(IRC, Correct))
    }
  }
  ans.opt.df <- ldply(item.list[number.answeroptions != 0], data.frame)
  names(ans.opt.df)[1] <- "id"
  ans.opt.df$Answer.Option <- gsub("Missing", "Mi", ans.opt.df$Answer.Option)
  ans.opt.df$Answer.Option <- factor(ans.opt.df$Answer.Option,
    levels = c(LETTERS[1:max(number.answeroptions)], "Mi"))
  ans.opt.df$id <- factor(ans.opt.df$id,
                          levels = item.names[number.answeroptions != 0])
  if (all(key == 0)) {
    ans.opt.df <- NULL
  }

  ans.opt.df
}

NumberOfPlots <- function(ans.opt.df, key) {
  # Calculates which item is displayed in which plot. The total number of
  # answer options is too large (usually) to display in one plot.
  #
  # Args:
  #  ans.opt.df: As defined in function above
  #
  # Returns:
  #  n.plots: the number of plots
  #  items.in.plot: list entry per plot. Every entry consists of item names
  #  in that plot

  if (any(key != 0)) {
    max.answ.opts <- 80 #  Maximum number of bars per plot
    tot.answ.opts <- nrow(ans.opt.df)
    n.plots <- ceiling(tot.answ.opts / max.answ.opts)
    answ.opts.per.plot <- floor(tot.answ.opts / n.plots)

    items.in.plot <- list(unique(ans.opt.df[1:answ.opts.per.plot, 1]))
    if (n.plots > 1) {
      for (i in 2:n.plots) {
        items.in.plot[[i]] <- unique(ans.opt.df[ (((i - 1) * answ.opts.per.plot)
                                     + 1): (i * answ.opts.per.plot), 1])
        if (items.in.plot[[i]][1] %in% items.in.plot[[i - 1]]) {
          items.in.plot[[i]] <- items.in.plot[[i]][-1]
        }
      }
    }
    assign("n.plots", n.plots, envir = globalenv())
    assign("items.in.plot", items.in.plot, envir = globalenv())

  }
}

ans.opt.df <- CreateAnsDf(item.list, key, number.answeroptions, item.names)
NumberOfPlots(ans.opt.df, key)

```

```{r, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE, fig.width = 11, results= 'asis'}    

PercPlotAnswOpt <- function(ans.opt.df, items.in.plot, key) {
  # Plots bar graph(s) of the percentages of every answer option
  #
  # Args:
  #  All defined as before
  #
  # Returns:
  #  Description of how to read the plots
  #  One or multiple plots

  if (any(key != 0)) {

    cat("\\pagebreak

## Percentage chosen per answer options

Percentage plot of all answer options per item. **White** bars represent the
**right** answer option(s) and **black** the **wrong** options.

The border represents the performance of an item. The **right** answer options
are coloured *green* if *more than 70%* of the students choose this option. In
that case, the students have mastered the material. They are coloured *red* if
*less than 40%* choose this option. *Between 40% and 70%*, it is coloured
*orange*.

The **wrong** answer options are coloured *green* if an option is chosen *10
percentage point less than the right option*. In that case, more students chose
the right answer option than the wrong option indicating that students are not
confused by the wrong option. They are coloured *red* if an option is chosen
*equally or more often than the right option*. In this case, students pick the
wrong answer option often, indicating that this option may be right as well. It
is coloured *orange* in between these two.

")

    for (i in 1:length(items.in.plot)) {
      bar.freq1 <- ggplot(ans.opt.df[ans.opt.df$id %in% items.in.plot[[i]], ],
        aes("Answer Option", Percentage, fill = Correct, colour = perc.col))
      bar.freq1 <- bar.freq1 + geom_bar(aes(x = Answer.Option),
                                        stat = "identity", size = 1.5) +
        facet_grid(. ~ id, scales = "free_x", space = "free_x") + #  Plot items
        scale_fill_manual(values = c("Incorrect" = "Black", #  Fill in the bars
                          "Correct" = "White"), guide = FALSE) +
        scale_colour_gradient(low = "red", high = "green", limits = c(0, 1),
                              guide = FALSE)  + #  Create colour boundary
        coord_cartesian(ylim = c(0, 100)) + #  Change y-axis limit to constant
        labs(x = "Answer Options") + # x  axis name
        theme_bw() +
        theme(axis.text.x = element_text(size = 8), # Font sizes
              axis.text.y = element_text(size = 12),
              axis.title.x = element_text(size = 15),
              axis.title.y = element_text(size = 15))

        suppressWarnings(print(bar.freq1))
    }
  }
}

IRCPlotAnswOpt <- function(ans.opt.df, items.in.plot, key) {
  # Plots bar graph(s) of the IRC of every answer option
  #
  # Args:
  #  All defined as before
  #
  # Returns:
  #  Description of how to read the plots
  #  One or multiple plots

  if (any(key != 0)) {

    cat('\\pagebreak

## Item rest correlations per answer option

Item rest correlation (IRC) plot of all answer options per item The IRC is the
correlation between an answer option (1 for students who chose this options and
0 for student who did not) and the sumscore on all other items. **White** bars
represent the **right** answer option(s) and **black** the **wrong** options.

The border represents the performance of an item. The **right** answer options
are coloured *green* if the IRC is *higher than .05*. In that case, students who
picked the right answer option scored higher on all other items than student who
did not pick the right option. They are coloured *red* if the IRC is *less than
0*. In that case, students who picked the right answer option scored equally or
worse on the other items than students who picked the other options. Between *0
and .05*, the option is coloured *orange*.

The **wrong** answer options are coloured *green* if the IRC is *more than .1
lower than the right option*. In that case, students who answered the other
items incorrectly, usually answered this item incorrectly as well. They are
coloured *red* if the IRC is *equal or higher than the right answer option*.
In that case, students who answered the other items correctly may have answered
this item incorrectly. In between these two, the option is coloured *orange*.

')

    # Creating IRC plots
    for (i in 1:length(items.in.plot)) {
      # Select items and variables to plot
      bar.IRC1 <- ggplot(ans.opt.df[ans.opt.df$id %in% items.in.plot[[i]], ],
        aes("Answer Option", IRC, fill = Correct, colour = IRC.col))
      bar.IRC1 <- bar.IRC1 + geom_bar(aes(x = Answer.Option), stat = "identity",
                                      size = 1.5) + #  Create Bar chart
        facet_grid(. ~ id, scales = "free_x", space = "free_x") +
        scale_fill_manual(values = c("Incorrect" = "Black", "Correct" = "White"),
                          guide = FALSE) + #  Fill in the bars
        scale_colour_gradient(low = "red", high = "green", limits = c(0, 1),
                              guide = FALSE)  + #  Create colour boundray
        # Change y-axis limit to either the maximum and minimum IRC
        coord_cartesian(ylim = c(min(ans.opt.df$IRC) - .01,
                                 max(ans.opt.df$IRC)  + .01)) +
        labs(x = "Answer Options") +
        theme_bw() +
        theme(axis.text.x = element_text(size = 8), #  Font sizes
              axis.text.y = element_text(size = 12),
              axis.title.x = element_text(size = 15),
              axis.title.y = element_text(size = 15)
        )
        suppressWarnings(print(bar.IRC1))
    }
  }
}

IRCPlotAnswOpt(ans.opt.df, items.in.plot, key)
PercPlotAnswOpt(ans.opt.df, items.in.plot, key)
```

\pagebreak

## Cumulative Distribution

Cumulative Distribution showing all possible scores and the percentage of 
students that scored that number or higher

```{r, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE, fig.width = 11}
CumHist <- function(student.scores, n.item) {
  # Create a reversed cumulative histogram, i.e. the height of score x is
  # the percentage of students who scores x or higher.
  #
  # Args:
  #  student.scores: numeric vector of test score per student.
  #  n.item: number of items
  #
  # Returns:
  #  Reversed cumulative histogram plot

  h <- heights <- length(student.scores)
  n <- sort(unique(student.scores))

  for (i in 1:length(n)) {
    h <- h - length(student.scores[student.scores == n[i]])
    heights <- c(heights, h)
  }

  cesuurlijnen <- seq(0.2, 0.8, 0.2) * length(student.scores)
  gridlijnen <- round(seq(0, length(student.scores),
                      length(student.scores) / 25), 0)

  gridlijnen <- gridlijnen[-grep(paste(round(cesuurlijnen, 0),
                           collapse = "|"), gridlijnen)]

  heights <- heights[1:length(unique(student.scores))]
  percent <- heights / length(student.scores) * 100
  df <- data.frame(score = sort(unique(student.scores)),
                   total = heights, percent = round(percent, 2))

  vec <- df[1, 1]:df[nrow(df), 1] #  save all possible total scores

  # Find if a total score is missing and add it
  mis <- NA
  if (sum(! (vec %in% df[, 1]) != 0)) {
    mis <- vec[! (vec %in% df[, 1])]
  }
  if (!is.na(mis[1])) {
    for (i in 1:length(mis)) {
      df[ (nrow(df) + 1), ] <- c(mis[i], 0, 0)
    }
    df <- df[order(df$score), ]
  }


  # if no one gets a certain total score, replace the 0 with the next total score
  suppressWarnings(
    df[which(df[, 2] == 0, arr.ind = TRUE), 2] <- df[ (which(df[, 2] == 0,
      arr.ind = TRUE) + 1), 2]
  )
  suppressWarnings(
    df[which(df[, 3] == 0, arr.ind = TRUE), 3] <- df[ (which(df[, 3] == 0,
      arr.ind = TRUE) + 1), 3]
  )

  g <- ggplot(data = df, aes(x = score, y = total)) +
    geom_hline(yintercept = c(gridlijnen), linetype = "solid",
               colour = "gray80") +
    geom_hline(yintercept = cesuurlijnen, linetype = "dashed", size = 0.75,
               colour = "black") +
    geom_histogram(stat = "identity", binwidth = 1) +
    xlab("Total score") + ylab("% of students with score or higher") +
    scale_y_continuous(breaks = c(0, cesuurlijnen, length(student.scores)),
                       labels = c(seq(0, 100, 20))) +
    scale_x_continuous(limits = c(df[1, 1] - 1, n.item + 1), breaks = 0:n.item,
                       expand = c(0, 0)) +
    theme_bw() +
    theme(panel.grid = element_blank())

  print(g)
}

CumHist(student.scores, n.item = ncol(key))
```

```{r, echo = FALSE, eval = TRUE, warnings = FALSE, message = FALSE, results = 'asis', fig.width = 11}
## Do the whole script above for every sub category
if (!length(categories) == 0) {
  cat("\n\n")
  cat("\\pagebreak")
  cat("\n\n")
  cat("# Analysis for subcategories")
  cat("\n\n")

  for (i in 1:length(categories)) {
    items <- categories[[i]]$items
    if (i != 1) {
      cat("\\pagebreak")
      cat("\n\n")
    }
    cat("\n\n")
    cat(paste("## Category:", categories[[i]]$name ))
    cat("\n\n")

    item.list <- CreateItemList(number.answeroptions[items],
      correct.frequency[items], correct.percentage[items],
      frequency.answer.options[, items], percentage.answer.options[, items],
      categories[[i]]$corrected.item.tot.cor,
      categories[[i]]$corrected.item.tot.cor.answ.option,
      item.names[items], key[, items])

    correct.df <- CreateDf(item.names[items], correct.percentage[items],
                           categories[[i]]$corrected.item.tot.cor)

    PercPlotOverall(correct.df)
    IRCPlotOverall(correct.df)

    if (any(key[, items] != 0)) {
      ans.opt.df <- CreateAnsDf(item.list, key[, items],
                                number.answeroptions[items], item.names[items])
      NumberOfPlots(ans.opt.df, key[, items])
      PercPlotAnswOpt(ans.opt.df, items.in.plot, key[, items])
      IRCPlotAnswOpt(ans.opt.df, items.in.plot, key[, items])
    }

    cat("\\pagebreak")
    cat("\n\n")
    cat("## Cumulative Distribution")
    cat("\n\n")
    CumHist(categories[[i]]$student.scores, n.item = length(items))
  }
}
```